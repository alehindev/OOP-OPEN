#include <iostream>
#include <bits/stdc++.h>

using namespace std;
/*
как подать значения для конструктор при динамическом выделении памяти 

---
Определение:

Конструктор — это особый тип метода, который вызывается при создании объекта класса.
---
Назначение:
 Конструкторы обычно используются для инициализации переменных-членов класса значениями, которые предоставлены по умолчанию  или пользователем, или для выполнения любых шагов настройки, необходимых для используемого класса. 

---
Способы оформления:
Т.к. она выделена по своей роли, то должна иметь выделенную структуру. 

Конструктор: 
1) не имеет типа (ибо возвращать нечего при создании нового объекта, кроме самого объекта)
2) имеет то же имя, что и класс.

---
Cпособы применения:
1) Конструкторы по умолчанию  - конструктор не содержащий параметров
2) Конструктор с параметрами - конструктор содержащий параметры, которые он может проинциализировать
3) Конструктор копирования  - конструктор, который копирует другой экземпляр того же класса
 
---
Отличие от перегрузки операции присваивания:

Конструктор копирования и оператор присваивания выполняют почти идентичную работу: оба копируют значения из одного объекта в значения другого объекта. Однако конструктор копирования используется при инициализации новых объектов, тогда как оператор присваивания заменяет содержимое уже существующих объектов.

---
Можно ли определить значение экземпляра класса бещ конструктора:
Да при том что все члены класса являются открытыми , можно используя список инициализаторов или uniform-инициализацию

someClass a = {1,3,4,5} //список инциализаторов
someClass b {1,2,3,4};

---
*/
class Matrix22
{
protected:
    double a11, a12, a21, a22;

public:
    Matrix22()
    {
        a11 = a12 = a21 = a22 = 0;
    }
    Matrix22(double A11, double A12, double A21, double A22)
    {
        a11 = A11;
        a12 = A12;
        a21 = A21;
        a22 = A22;
    }
    Matrix22(const Matrix22 &obj)
    {
        a11 = obj.a11;
        a12 = obj.a12;
        a21 = obj.a21;
        a22 = obj.a22;
    }

    Matrix22 operator+(int val)
    {
        Matrix22 Res;
        Res.a11 = a11 + val;
        Res.a12 = a12;
        Res.a21 = a21;
        Res.a22 = a22 + val;
        return Res;
    }
    Matrix22 operator-(int val)
    {
        Matrix22 Res;
        Res.a11 = a11 - val;
        Res.a12 = a12;
        Res.a21 = a21;
        Res.a22 = a22 - val;
        return Res;
    }
    Matrix22 operator-(Matrix22 obj)
    {
        Matrix22 Res;
        Res.a11 = a11 - obj.a11;
        Res.a12 = a12;
        Res.a21 = a21;
        Res.a22 = a22 - obj.a22;
        return Res;
    }

    Matrix22 operator+(Matrix22 obj)
    {
        Matrix22 Res;
        Res.a11 = a11 + obj.a11;
        Res.a12 = a12;
        Res.a21 = a21;
        Res.a22 = a22 + obj.a22;
        return Res;
    }
    friend Matrix22 operator-(double val, Matrix22 obj)
    {
        Matrix22 Res(val - obj.a11, -obj.a12, -obj.a21, val - obj.a22);
        return Res;
    }
    friend Matrix22 operator+(double val, Matrix22 obj)
    {
        Matrix22 Res(val + obj.a11, obj.a12, obj.a21, val + obj.a22);
        return Res;
    }
    void print()
    {
        cout << a11 << "  " << a12 << endl
             << a21 << "  " << a22 << endl
             << endl;
        return;
    }
};

int main()
{
    Matrix22 a(1, 1, 1, 1);
    Matrix22 b = 1 - a;
    Matrix22 c(1, 1, 1, 1);
    cout << "Test b = 1 - a" << endl;
    a.print();
    b.print();

    cout << "Test c = b = a + c" << endl;
    c = b = a + c;
    a.print();
    b.print();
    c.print();

    return 0;
}